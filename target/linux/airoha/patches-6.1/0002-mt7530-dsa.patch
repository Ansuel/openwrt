--- a/drivers/net/dsa/mt7530-mmio.c
+++ b/drivers/net/dsa/mt7530-mmio.c
@@ -11,6 +11,7 @@
 
 static const struct of_device_id mt7988_of_match[] = {
 	{ .compatible = "mediatek,mt7988-switch", .data = &mt753x_table[ID_MT7988], },
+	{ .compatible = "airoha,en7581-switch", .data = &mt753x_table[ID_EN7581], },
 	{ /* sentinel */ },
 };
 MODULE_DEVICE_TABLE(of, mt7988_of_match);
@@ -59,7 +60,11 @@ mt7988_probe(struct platform_device *pde
 	if (IS_ERR(priv->regmap))
 		return PTR_ERR(priv->regmap);
 
-	return dsa_register_switch(priv->ds);
+	ret = dsa_register_switch(priv->ds);
+	if (ret)
+		return ret;
+
+	return mt7530_register_debugfs(priv);
 }
 
 static int
--- a/drivers/net/dsa/mt7530.h
+++ b/drivers/net/dsa/mt7530.h
@@ -19,6 +19,7 @@ enum mt753x_id {
 	ID_MT7621 = 1,
 	ID_MT7531 = 2,
 	ID_MT7988 = 3,
+	ID_EN7581 = 4,
 };
 
 #define	NUM_TRGMII_CTRL			5
@@ -54,13 +55,46 @@ enum mt753x_id {
 #define  MT7531_MIRROR_PORT_GET(x)	(((x) >> 16) & MIRROR_MASK)
 #define  MT7531_MIRROR_PORT_SET(x)	(((x) & MIRROR_MASK) << 16)
 #define  MT7531_CPU_PMAP_MASK		GENMASK(7, 0)
+#define  MT7531_CPU_PMAP(x)		FIELD_PREP(MT7531_CPU_PMAP_MASK, x)
 
-#define MT753X_MIRROR_REG(id)		((((id) == ID_MT7531) || ((id) == ID_MT7988)) ?	\
-					 MT7531_CFC : MT7530_MFC)
-#define MT753X_MIRROR_EN(id)		((((id) == ID_MT7531) || ((id) == ID_MT7988)) ?	\
-					 MT7531_MIRROR_EN : MIRROR_EN)
-#define MT753X_MIRROR_MASK(id)		((((id) == ID_MT7531) || ((id) == ID_MT7988)) ?	\
-					 MT7531_MIRROR_MASK : MIRROR_MASK)
+#define MT753X_MIRROR_REG(id)		((((id) == ID_MT7531) || ((id) == ID_MT7988) ||	\
+					  ((id) == ID_EN7581)) ? MT7531_CFC : MT7530_MFC)
+#define MT753X_MIRROR_EN(id)		((((id) == ID_MT7531) || ((id) == ID_MT7988) ||	\
+					  ((id) == ID_EN7581)) ? MT7531_MIRROR_EN : MIRROR_EN)
+#define MT753X_MIRROR_MASK(id)		((((id) == ID_MT7531) || ((id) == ID_MT7988) ||	\
+					  ((id) == ID_EN7581)) ? MT7531_MIRROR_MASK : MIRROR_MASK)
+
+/* Registers for IGMP and MLD frame control*/
+#define MT753X_IMC			0x1c
+#define  MT753X_MLD_MANG_FR_MASK	BIT(27)
+#define  MT753X_MLD_EG_TAG_MASK		GENMASK(18, 16)
+#define  MT753X_MLD_EG_TAG(x)		FIELD_PREP(MT753X_MLD_EG_TAG_MASK, x)
+#define  MT753X_IGMP_MANG_FR_MASK	BIT(11)
+#define  MT753X_IGMP_PORT_FW_MASK	GENMASK(2, 0)
+#define  MT753X_IGMP_EG_TAG(x)		FIELD_PREP(MT753X_IGMP_PORT_FW_MASK, x)
+
+enum mt753x_imc_port_fw {
+	MT753X_IMC_CPU_EXCLUDE = 4,
+	MT753X_IMC_CPU_INCLUDE = 5,
+	MT753X_IMC_CPU_ONLY = 6,
+	MT753X_IMC_DROP = 7,
+};
+
+/* Registers for ARP and PPP frame control*/
+#define MT753X_APC			0x20
+#define  MT753X_PPP_MANG_FR_MASK	BIT(27)
+#define  MT753X_PPP_EG_TAG_MASK		GENMASK(18, 16)
+#define  MT753X_PPP_EG_TAG(x)		FIELD_PREP(MT753X_PPP_EG_TAG_MASK, x)
+#define  MT753X_ARP_MANG_FR_MASK	BIT(11)
+#define  MT753X_ARP_PORT_FW_MASK	GENMASK(2, 0)
+#define  MT753X_ARP_EG_TAG(x)		FIELD_PREP(MT753X_ARP_PORT_FW_MASK, x)
+
+enum mt753x_apc_port_fw {
+	MT753X_APC_CPU_EXCLUDE = 4,
+	MT753X_APC_CPU_INCLUDE = 5,
+	MT753X_APC_CPU_ONLY = 6,
+	MT753X_APC_DROP = 7,
+};
 
 /* Registers for BPDU and PAE frame control*/
 #define MT753X_BPC			0x24
@@ -194,6 +228,22 @@ enum mt7530_vlan_egress_attr {
 #define  AGE_UNIT_MAX			0xfff
 #define  AGE_UNIT(x)			(AGE_UNIT_MASK & (x))
 
+/* Registers for DHCP and DHCP6 frame control*/
+#define MT753X_DPC			0xa4
+#define  MT753X_DHCP6_MANG_FR_MASK	BIT(27)
+#define  MT753X_DHCP6_EG_TAG_MASK	GENMASK(18, 16)
+#define  MT753X_DHCP6_EG_TAG(x)		FIELD_PREP(MT753X_DHCP6_EG_TAG_MASK, x)
+#define  MT753X_DHCP_MANG_FR_MASK	BIT(11)
+#define  MT753X_DHCP_PORT_FW_MASK	GENMASK(2, 0)
+#define  MT753X_DHCP_EG_TAG(x)		FIELD_PREP(MT753X_DHCP_PORT_FW_MASK, x)
+
+enum mt753x_dpc_port_fw {
+	MT753X_DPC_CPU_EXCLUDE = 4,
+	MT753X_DPC_CPU_INCLUDE = 5,
+	MT753X_DPC_CPU_ONLY = 6,
+	MT753X_DPC_DROP = 7,
+};
+
 /* Register for port STP state control */
 #define MT7530_SSP_P(x)			(0x2000 + ((x) * 0x100))
 #define  FID_PST(fid, state)		(((state) & 0x3) << ((fid) * 2))
@@ -303,7 +353,7 @@ enum mt7530_vlan_port_acc_frm {
 					 MT7531_FORCE_DPX | \
 					 MT7531_FORCE_RX_FC | \
 					 MT7531_FORCE_TX_FC)
-#define  PMCR_FORCE_MODE_ID(id)		((((id) == ID_MT7531) || ((id) == ID_MT7988)) ?	\
+#define  PMCR_FORCE_MODE_ID(id)		((((id) == ID_MT7531) || ((id) == ID_MT7988) || ((id) == ID_EN7581)) ?	\
 					 MT7531_FORCE_MODE : PMCR_FORCE_MODE)
 #define  PMCR_LINK_SETTINGS_MASK	(PMCR_TX_EN | PMCR_FORCE_SPEED_1000 | \
 					 PMCR_RX_EN | PMCR_FORCE_SPEED_100 | \
@@ -352,6 +402,12 @@ enum mt7530_vlan_port_acc_frm {
 #define  MAX_RX_PKT_LEN_1552		0x2
 #define  MAX_RX_PKT_LEN_JUMBO		0x3
 
+#define MT7530_DGCR			0x30ec
+
+#define MT7530_CKGCR			0x30f0
+#define CFG_LNKDN_GLB			BIT(0)
+#define CFG_LNKDN_PORT			BIT(1)
+
 /* Register for MIB */
 #define MT7530_PORT_MIB_COUNTER(x)	(0x4000 + (x) * 0x100)
 #define MT7530_MIB_CCR			0x4fe0
@@ -479,6 +535,7 @@ enum mt7531_clk_skew {
 /* Register for TOP signal control */
 #define MT7530_TOP_SIG_CTRL		0x7808
 #define  TOP_SIG_CTRL_NORMAL		(BIT(17) | BIT(16))
+#define  PHY_MDC_CK_EN			BIT(0)
 
 #define MT7531_TOP_SIG_SR		0x780c
 #define  PAD_DUAL_SGMII_EN		BIT(1)
@@ -651,6 +708,13 @@ enum mt7531_clk_skew {
 		.name = (_n),	\
 	}
 
+#define EN7581_CPORT_CFG		0xfc00
+#define  CPORT_FE2GSW_CRC_DIS		BIT(31)
+#define  CPORT_PAD_EN			BIT(26)
+#define  CPORT_FEP_XFC			BIT(25)
+#define  CPORT_FEQ_XFC			BIT(24)
+#define  CPORT_FE2GSW_IPG		GENMASK(15, 8)
+
 struct mt7530_mib_desc {
 	unsigned int size;
 	unsigned int offset;
@@ -778,6 +842,8 @@ struct mt7530_priv {
 	struct irq_domain *irq_domain;
 	u32 irq_enable;
 	int (*create_sgmii)(struct mt7530_priv *priv, bool dual_sgmii);
+	struct dentry *debugfs_dir;
+	u32 debugfs_reg;
 };
 
 struct mt7530_hw_vlan_entry {
@@ -814,6 +880,7 @@ static inline void INIT_MT7530_DUMMY_POL
 	p->reg = reg;
 }
 
+int mt7530_register_debugfs(struct mt7530_priv *priv);
 int mt7530_probe_common(struct mt7530_priv *priv);
 void mt7530_remove_common(struct mt7530_priv *priv);
 
--- a/drivers/net/dsa/mt7530.c
+++ b/drivers/net/dsa/mt7530.c
@@ -3,6 +3,7 @@
  * Mediatek MT7530 DSA Switch driver
  * Copyright (C) 2017 Sean Wang <sean.wang@mediatek.com>
  */
+#include <linux/debugfs.h>
 #include <linux/etherdevice.h>
 #include <linux/if_bridge.h>
 #include <linux/iopoll.h>
@@ -286,6 +287,28 @@ mt7530_clear(struct mt7530_priv *priv, u
 }
 
 static int
+mt7530_reg_set(void *data, u64 val)
+{
+	struct mt7530_priv *priv = data;
+
+	mt7530_write(priv, priv->debugfs_reg, val);
+
+	return 0;
+}
+
+static int
+mt7530_reg_get(void *data, u64 *val)
+{
+	struct mt7530_priv *priv = data;
+
+	*val = mt7530_read(priv, priv->debugfs_reg);
+
+	return 0;
+}
+
+DEFINE_DEBUGFS_ATTRIBUTE(fops, mt7530_reg_get, mt7530_reg_set, "0x%08llx\n");
+
+static int
 mt7530_fdb_cmd(struct mt7530_priv *priv, enum mt7530_fdb_cmd cmd, u32 *rsp)
 {
 	u32 val;
@@ -1030,7 +1053,7 @@ mt753x_cpu_port_enable(struct dsa_switch
 		   UNU_FFP(BIT(port)));
 
 	/* Set CPU port number */
-	if (priv->id == ID_MT7530 || priv->id == ID_MT7621)
+	if (priv->id == ID_MT7530 || priv->id == ID_MT7621 || priv->id == ID_EN7581)
 		mt7530_rmw(priv, MT7530_MFC, CPU_MASK, CPU_EN | CPU_PORT(port));
 
 	/* CPU port gets connected to all user ports of
@@ -2079,7 +2102,7 @@ mt7530_setup_irq(struct mt7530_priv *pri
 		return priv->irq ? : -EINVAL;
 	}
 
-	if (priv->id == ID_MT7988)
+	if (priv->id == ID_MT7988 || priv->id == ID_EN7581)
 		priv->irq_domain = irq_domain_add_linear(np, MT7530_NUM_PHYS,
 							 &mt7988_irq_domain_ops,
 							 priv);
@@ -3117,6 +3140,62 @@ static int mt7988_setup(struct dsa_switc
 	return mt7531_setup_common(ds);
 }
 
+static int en7581_setup(struct dsa_switch *ds)
+{
+	struct mt7530_priv *priv = ds->priv;
+	int i, err;
+
+	/* Reset the switch */
+	reset_control_assert(priv->rstc);
+	usleep_range(20, 50);
+	reset_control_deassert(priv->rstc);
+	usleep_range(20, 50);
+
+	/* Reset the switch PHYs */
+	mt7530_write(priv, MT7530_SYS_CTRL, SYS_CTRL_PHY_RST);
+
+	err = mt7531_setup_common(ds);
+	if (err)
+		return err;
+
+	/* IGMP and MLD config */
+	mt7530_rmw(priv, MT753X_IMC,
+		   MT753X_MLD_MANG_FR_MASK | MT753X_MLD_EG_TAG_MASK |
+		   MT753X_IGMP_MANG_FR_MASK | MT753X_IGMP_PORT_FW_MASK,
+		   MT753X_MLD_EG_TAG(MT753X_IMC_CPU_ONLY) |
+		   MT753X_IGMP_EG_TAG(MT753X_IMC_CPU_ONLY));
+	/* ARP and PPP config */
+	mt7530_rmw(priv, MT753X_APC,
+		   MT753X_PPP_MANG_FR_MASK | MT753X_PPP_EG_TAG_MASK |
+		   MT753X_ARP_MANG_FR_MASK | MT753X_ARP_PORT_FW_MASK,
+		   MT753X_PPP_EG_TAG(MT753X_APC_CPU_ONLY) |
+		   MT753X_ARP_EG_TAG(MT753X_APC_CPU_ONLY));
+	/* DHCP and DHCP6 config */
+	mt7530_rmw(priv, MT753X_DPC,
+		   MT753X_DHCP6_MANG_FR_MASK | MT753X_DHCP6_EG_TAG_MASK |
+		   MT753X_DHCP_MANG_FR_MASK | MT753X_DHCP_PORT_FW_MASK,
+		   MT753X_DHCP6_EG_TAG(MT753X_DPC_CPU_ONLY) |
+		   MT753X_DHCP_EG_TAG(MT753X_DPC_CPU_ONLY));
+
+	mt7530_clear(priv, MT7530_CKGCR, CFG_LNKDN_GLB | CFG_LNKDN_PORT);
+	mt7530_set(priv, EN7581_CPORT_CFG,
+		   CPORT_FE2GSW_CRC_DIS | CPORT_PAD_EN | CPORT_FEP_XFC);
+	mt7530_clear(priv, EN7581_CPORT_CFG, CPORT_FEQ_XFC);
+	mt7530_rmw(priv, EN7581_CPORT_CFG, CPORT_FE2GSW_IPG,
+		   FIELD_PREP(CPORT_FE2GSW_IPG, 0x2));
+	mt7530_write(priv, MT7530_DGCR, 0x2);
+
+	/* TRGMII setup */
+	for (i = 0; i < NUM_TRGMII_CTRL; i++)
+		mt7530_rmw(priv, MT7530_TRGMII_RD(i), RD_TAP_MASK, RD_TAP(1));
+	mt7530_clear(priv, MT7530_TOP_SIG_CTRL, PHY_MDC_CK_EN);
+	mt7530_write(priv, MT7530_MHWTRAP, 0x01017e8f);
+	mt7530_set(priv, MT7530_TOP_SIG_CTRL, PHY_MDC_CK_EN);
+	mt7530_rmw(priv, MT7530_P6ECR, P6_INTF_MODE_MASK, P6_INTF_MODE(1));
+
+	return 0;
+}
+
 const struct dsa_switch_ops mt7530_switch_ops = {
 	.get_tag_protocol	= mtk_get_tag_protocol,
 	.setup			= mt753x_setup,
@@ -3196,10 +3275,37 @@ const struct mt753x_info mt753x_table[]
 		.mac_port_get_caps = mt7988_mac_port_get_caps,
 		.mac_port_config = mt7988_mac_config,
 	},
+	[ID_EN7581] = {
+		.id = ID_EN7581,
+		.pcs_ops = &mt7530_pcs_ops,
+		.sw_setup = en7581_setup,
+		.phy_read = mt7531_ind_phy_read,
+		.phy_write = mt7531_ind_phy_write,
+		.pad_setup = mt7988_pad_setup,
+		.cpu_port_config = mt7988_cpu_port_config,
+		.mac_port_get_caps = mt7988_mac_port_get_caps,
+		.mac_port_config = mt7988_mac_config,
+	},
 };
 EXPORT_SYMBOL_GPL(mt753x_table);
 
 int
+mt7530_register_debugfs(struct mt7530_priv *priv)
+{
+	priv->debugfs_dir = debugfs_create_dir(KBUILD_MODNAME, NULL);
+	if (IS_ERR(priv->debugfs_dir))
+		return PTR_ERR(priv->debugfs_dir);
+
+	debugfs_create_u32("regidx", 0600, priv->debugfs_dir,
+			   &priv->debugfs_reg);
+	debugfs_create_file_unsafe("regval", 0600, priv->debugfs_dir, priv,
+				   &fops);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(mt7530_register_debugfs);
+
+int
 mt7530_probe_common(struct mt7530_priv *priv)
 {
 	struct device *dev = priv->dev;
@@ -3241,6 +3347,8 @@ EXPORT_SYMBOL_GPL(mt7530_probe_common);
 void
 mt7530_remove_common(struct mt7530_priv *priv)
 {
+	debugfs_remove(priv->debugfs_dir);
+
 	if (priv->irq)
 		mt7530_free_irq(priv);
 
