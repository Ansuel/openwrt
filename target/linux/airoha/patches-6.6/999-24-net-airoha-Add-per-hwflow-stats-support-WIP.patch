From 23164e9201376001f83e05a942f6e384a87bfd1f Mon Sep 17 00:00:00 2001
Message-ID: <23164e9201376001f83e05a942f6e384a87bfd1f.1739091238.git.lorenzo@kernel.org>
In-Reply-To: <2d7258a579bf337e2f77c3df7fa87b5d2c7d7045.1739091238.git.lorenzo@kernel.org>
References: <2d7258a579bf337e2f77c3df7fa87b5d2c7d7045.1739091238.git.lorenzo@kernel.org>
From: Lorenzo Bianconi <lorenzo@kernel.org>
Date: Fri, 7 Feb 2025 18:42:38 +0100
Subject: [PATCH net-next 6/6] net: airoha: Add per-hwflow stats support (WIP)

Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
---
 drivers/net/ethernet/airoha/airoha_eth.h |  5 ++
 drivers/net/ethernet/airoha/airoha_ppe.c | 65 ++++++++++++++++++++++++
 2 files changed, 70 insertions(+)

--- a/drivers/net/ethernet/airoha/airoha_eth.h
+++ b/drivers/net/ethernet/airoha/airoha_eth.h
@@ -399,6 +399,11 @@ struct airoha_foe_entry {
 	};
 };
 
+struct airoha_foe_stats {
+	u64 bytes;
+	u64 packets;
+};
+
 struct airoha_flow_data {
 	struct ethhdr eth;
 
--- a/drivers/net/ethernet/airoha/airoha_ppe.c
+++ b/drivers/net/ethernet/airoha/airoha_ppe.c
@@ -425,6 +425,28 @@ static void airoha_ppe_foe_flow_remove_e
 	spin_unlock_bh(&ppe_lock);
 }
 
+static void airoha_ppe_foe_flow_update_ib1(struct airoha_ppe *ppe,
+					   struct airoha_flow_table_entry *e)
+{
+	struct airoha_foe_entry *hwe;
+
+	if (e->hash == 0xffff)
+		return;
+
+	spin_lock_bh(&ppe_lock);
+
+	hwe = airoha_ppe_foe_get_entry(ppe, e->hash);
+	if (!hwe)
+		goto unlock;
+
+	if (!airoha_ppe_foe_compare_entry(e, hwe))
+		goto unlock;
+
+	e->data.ib1 = hwe->ib1;
+unlock:
+	spin_unlock_bh(&ppe_lock);
+}
+
 static int airoha_ppe_flow_offload_replace(struct airoha_gdm_port *port,
 					   struct flow_cls_offload *f)
 {
@@ -657,6 +679,46 @@ static int airoha_ppe_flow_offload_destr
 	return 0;
 }
 
+static bool airoha_ppe_foe_entry_get_stats(struct airoha_ppe *ppe, u32 hash,
+					   struct airoha_foe_stats *stats)
+{
+	/* FIXME: read stats and populate airoha_foe_stats struct */
+	return true;
+}
+
+static int airoha_ppe_flow_offload_stats(struct airoha_gdm_port *port,
+					 struct flow_cls_offload *f)
+{
+	struct airoha_eth *eth = port->qdma->eth;
+	struct airoha_foe_stats stats = {};
+	struct airoha_flow_table_entry *e;
+	u32 ts, now;
+	int idle;
+
+	e = rhashtable_lookup(&eth->flow_table, &f->cookie,
+			      airoha_flow_table_params);
+	if (!e)
+		return -ENOENT;
+
+	airoha_ppe_foe_flow_update_ib1(eth->ppe, e);
+
+	ts = FIELD_GET(AIROHA_FOE_IB1_BIND_TIMESTAMP, e->data.ib1);
+	now = airoha_ppe_get_timestamp(eth->ppe);
+	idle = now - ts;
+	if (ts > now)
+		idle += AIROHA_FOE_IB1_BIND_TIMESTAMP + 1;
+
+	f->stats.lastused = jiffies - idle * HZ;
+	if (e->hash != 0xffff &&
+	    airoha_ppe_foe_entry_get_stats(eth->ppe, e->hash,
+					   &stats)) {
+		f->stats.pkts += stats.packets;
+		f->stats.bytes += stats.bytes;
+	}
+
+	return 0;
+}
+
 static int airoha_ppe_flow_offload_cmd(struct airoha_gdm_port *port,
 				       struct flow_cls_offload *f)
 {
@@ -671,6 +733,9 @@ static int airoha_ppe_flow_offload_cmd(s
 	case FLOW_CLS_DESTROY:
 		err = airoha_ppe_flow_offload_destroy(port, f);
 		break;
+	case FLOW_CLS_STATS:
+		err = airoha_ppe_flow_offload_stats(port, f);
+		break;
 	default:
 		break;
 	}
