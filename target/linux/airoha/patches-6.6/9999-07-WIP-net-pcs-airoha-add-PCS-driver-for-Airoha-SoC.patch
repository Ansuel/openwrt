From 7dec7b5840a1e2be62de7a2e8dd2a9ed26124ae2 Mon Sep 17 00:00:00 2001
From: Christian Marangi <ansuelsmth@gmail.com>
Date: Fri, 17 Jan 2025 12:40:32 +0100
Subject: [PATCH 7/9] WIP net: pcs: airoha: add PCS driver for Airoha SoC

Add PCS driver for Airoha SoC for ethernet SERDES and permit usage of
external PHY or connected SFP cage. Supported modes are USXGMII, HSGMII
at fixed link and SGMII.

The driver probe and register the various needed registers and expose
the pcs_create and pcs_destroy symbol to make them usable by the Airoha
Ethernet driver.

Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
---
 drivers/net/pcs/Kconfig        |   6 +
 drivers/net/pcs/Makefile       |   1 +
 drivers/net/pcs/pcs-airoha.c   | 952 +++++++++++++++++++++++++++++++++
 include/linux/pcs/pcs-airoha.h |  16 +
 4 files changed, 975 insertions(+)
 create mode 100644 drivers/net/pcs/pcs-airoha.c
 create mode 100644 include/linux/pcs/pcs-airoha.h

--- a/drivers/net/pcs/Kconfig
+++ b/drivers/net/pcs/Kconfig
@@ -5,6 +5,12 @@
 
 menu "PCS device drivers"
 
+config PCS_AIROHA
+	tristate "Airoha PCS driver"
+	help
+	  This module provides helper to phylink for managing the Airoha
+	  PCS for SoC Ethernet SERDES.
+
 config PCS_XPCS
 	tristate
 	select PHYLINK
--- a/drivers/net/pcs/Makefile
+++ b/drivers/net/pcs/Makefile
@@ -1,6 +1,7 @@
 # SPDX-License-Identifier: GPL-2.0
 # Makefile for Linux PCS drivers
 
+obj-$(CONFIG_PCS_AIROHA)	+= pcs-airoha.o
 pcs_xpcs-$(CONFIG_PCS_XPCS)	:= pcs-xpcs.o pcs-xpcs-nxp.o pcs-xpcs-wx.o
 
 obj-$(CONFIG_PCS_XPCS)		+= pcs_xpcs.o
--- /dev/null
+++ b/drivers/net/pcs/pcs-airoha.c
@@ -0,0 +1,952 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2024 AIROHA Inc
+ * Author: Christian Marangi <ansuelsmth@gmail.com>
+ */
+
+#include <linux/device.h>
+#include <linux/mfd/syscon.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/pcs/pcs-airoha.h>
+#include <linux/phylink.h>
+#include <linux/platform_device.h>
+#include <linux/regmap.h>
+
+/* SCU*/
+#define SCU_SSR3		0x94
+
+/* HSGMII_AN */
+#define HSGMII_SGMII_AN         0x0
+
+/* HSGMII_PCS */
+#define HSGMII_XSGMII_INIT      0x0
+
+/* MULTI_SGMII */
+#define HSGMII_HSGMII_INIT      0x18
+#define HSGMII_USXGMII_INIT     0x100
+
+/* HSGMII_RATE_ADP */
+#define HSGMII_HSGMII_25G		0x0
+#define HSGMII_HSGMII_XFI		0x2c
+
+/* USXGMII */
+#define HSGMII_PCS_CTROL_1		0x900
+#define HSGMII_USXGMII_PCS_E0E1		0xb2c
+#define HSGMII_USXGMII_INT_EN1		0xbc0
+#define HSGMII_USXGMII_INT_EN2		0xbc4
+#define HSGMII_USXGMII_INT_EN3		0xbc8
+#define HSGMII_USXGMII_INT_EN4		0xbcc
+#define HSGMII_USXGMII_INT_EN5		0xbe0
+#define HSGMII_USXGMII_INT_EN6		0xbd8
+#define HSGMII_USXGMII_INT_EN7		0xbdc
+#define HSGMII_USXGMII_INT_EN8		0xbe4
+#define HSGMII_USXGMII_INT_EN9		0xbc8
+#define HSGMII_USXGMII_INT_EN10		0xbcc
+#define HSGMII_USXGMII_INT_EN11		0xbe0
+#define HSGMII_USXGMII_AN_EN		0xbf8
+#define HSGMII_USXGMII_AN_STATS_0	0xc10
+#define HSGMII_USXGMII_AN_CONTROL_6	0xc1c
+#define HSGMII_USXGMII_AN_STATS_2	0xc18
+
+/* PMA_PHYA */
+#define PHYA_PXP_CMN_EN		0x0
+#define PHYA_JCPLL_LPF1		0x4
+#define PHYA_JCPLL_LPF2		0x8
+#define PHYA_JCPLL_LPF3		0xc
+#define PHYA_JCPLL_KBand	0x10
+#define PHYA_JCPLL_DIV		0x14
+#define PHYA_JCPLL_RSTB		0x1c
+#define PHYA_JCPLL_SDM1		0x20
+#define PHYA_JCPLL_SDM2		0x24
+#define PHYA_JCPLL_TCL2		0x28
+#define PHYA_JCPLL_VCO		0x2c
+#define PHYA_JCPLL_SSC1		0x30
+#define PHYA_JCPLL_SSC2		0x34
+#define PHYA_JCPLL_SSC3		0x38
+#define PHYA_JCPLL_LDO		0x48
+#define PHYA_TXPLL_LPF1		0x50
+#define PHYA_TXPLL_LPF2		0x54
+#define PHYA_TXPLL_KBand1	0x58
+#define PHYA_TXPLL_KBand2	0x5c
+#define PHYA_TXPLL_RSTB		0x64
+#define PHYA_TXPLL_SDM1		0x68
+#define PHYA_TXPLL_SDM2		0x6c
+#define PHYA_TXPLL_TCL		0x70
+#define PHYA_TXPLL_VCO1		0x74
+#define PHYA_TXPLL_VCO2		0x78
+#define PHYA_TXPLL_SSC2		0x7c
+#define PHYA_TXPLL_SSC1		0x80
+#define PHYA_TXPLL_VCOLDO_Out	0x84
+#define PHYA_TXPLL_PCW1		0x94
+#define PHYA_TX_CONFIG1		0xc4
+#define PHYA_PXP_RX_PHYCK2	0xcc
+#define PHYA_RX_REV		0xd4
+#define PHYA_PXP_RX_PHYCK1	0xd8
+#define PHYA_RX_Path_Init10	0xdc
+#define PHYA_CDR_LPF_RATIO	0xe8
+#define PHYA_RX_PRCal6		0xf4
+#define PHYA_PXP_CDR_PR_INJ_MODE 0xf4
+#define PHYA_CDR_PR1		0xf8
+#define PHYA_CDR_PR2		0xfc
+#define PHYA_RX_Path_Init13	0x10c
+#define PHYA_RX_SigDet		0x110
+#define PHYA_RX_IMP		0x114
+#define PHYA_RX_CMLEQ_EN	0x118
+#define PHYA_RX_Path_Init4	0x11c
+#define PHYA_RX_Path_Init7	0x120
+#define PHYA_RX_Path_Init6	0x13c
+#define PHYA_RX_Path_Init3	0x144
+#define PHYA_RX_Path_Init2	0x148
+#define PHYA_RX_FLL_PR_FMeter1	0x390
+#define PHYA_RX_FLL_PR_FMeter2	0x394
+#define PHYA_RX_FLL_PR_FMeter3	0x39c
+
+/* PMA_PHYD */
+#define PHYD_RX_SYS_En2		0x0
+#define PHYD_RX_Path_Init5	0x4
+#define PHYD_RX_EYE_Mon2	0x88
+#define PHYD_RX_CalBoundry_Init1 0x8c
+#define PHYD_RX_CalBoundry_Init3 0x90
+#define PHYD_RX_CalBoundry_Init5 0x94
+#define PHYD_RX_CalBoundry_Init6 0x98
+#define PHYD_RX_CalBoundry_Init4 0x9c
+#define PHYD_RX_Rdy_TimeOut	0x100
+#define PHYD_RX_CalBoundry_Init2 0x104
+#define PHYD_RX_EYE_Mon1	0x120
+#define PHYD_RX_PRCal3		0x14c
+#define PHYD_SS_RX_FREQ_DET_1	0x14c
+#define PHYD_RX_PRCal2		0x150
+#define PHYD_SS_RX_FREQ_DET_2	0x150
+#define PHYD_RX_PRCal5		0x154
+#define PHYD_SS_RX_FREQ_DET_3	0x154
+#define PHYD_RX_PRCal4		0x158
+#define PHYD_SS_RX_FREQ_DET_4	0x158
+#define PHYD_SS_RX_FLL_1	0x174
+#define PHYD_RX_Path_Init1	0x184
+#define PHYD_SS_RX_FLL_b        0x19c
+#define PHYD_TX_RSTB		0x260
+#define PHYD_RX_Path_Init8	0x320
+#define PHYD_RX_FLL_PR_FMeter2	0x330
+#define PHYD_RX_FLL_PR_FMeter1	0x33c
+#define PHYD_RX_SYS_En1		0x38c
+#define PHYD_RX_Path_Init9	0x48c
+#define PHYD_RX_CDR_xxx_Pwdb5	0x34c
+#define PHYD_RX_SigDet_Pwdb	0x350
+#define PHYD_RESERVE_0		0x360
+#define PHYD_RESERVE_2		0x380
+#define PHYD_rx_rate_ctrl	0x374
+#define PHYD_RX_PRCal1		0x460
+#define PHYD_SW_RST_SET		0x460
+#define PHYD_RX_FREQDET		0x530
+#define PHYD_tx_rate_ctrl	0x580
+#define PHYD_RX_FE2		0x768
+#define PHYD_RX_OSR		0x76c
+#define PHYD_TX_FIR1		0x778
+#define PHYD_TX_CONFIG3		0x77c
+#define PHYD_TX_FIR2		0x780
+#define PHYD_TX_CONFIG4		0x784
+#define PHYD_RX_PRCal8		0x794
+#define PHYD_FORCE_DA_PXP_CDR_PR_IDAC 0x794
+#define PHYD_FORCE_DA_PXP_TXPLL_SDM_PCW 0x798
+#define PHYD_JCPLL_PCW1		0x79c
+#define PHYD_JCPLL_PCW2		0x800
+#define PHYD_RX_Path_Init11	0x80c
+#define PHYD_RX_Path_Init12	0x814
+#define PHYD_RX_CDR_LFP_L2D	0x818
+#define PHYD_RX_CDR_xxx_Pwdb2	0x81c
+#define PHYD_RX_PRCal7		0x820
+#define PHYD_FORCE_DA_PXP_CDR_PR_LPF 0x820
+#define PHYD_RX_CDR_xxx_Pwdb1	0x824
+#define PHYD_FORCE_DA_PXP_CDR_PR_PIEYE_PWDB 0x824
+#define PHYD_JCPLL_EN		0x828
+#define PHYD_RX_CDR_xxx_Pwdb4	0x84c
+#define PHYD_TXPLL_EN		0x854
+#define PHYD_TX_CONFIG2		0x874
+#define PHYD_RX_FE1		0x88c
+#define PHYD_RX_CDR_xxx_Pwdb3	0x894
+#define PHYD_RX_FE_VOS		0x79c
+
+struct airoha_pcs_priv {
+	struct regmap *scu;
+
+	struct regmap *xfi_mac;
+	struct regmap *hsgmii_an;
+	struct regmap *hsgmii_pcs;
+	// struct regmap *hsgmii_analog;
+	struct regmap *hsgmii_rate_adp;
+	struct regmap *multi_sgmii;
+	struct regmap *usxgmii;
+
+	struct regmap *xfi_pma;
+	struct regmap *xfi_ana;
+};
+
+struct airoha_pcs_port {
+	struct airoha_pcs_priv *priv;
+
+	struct phylink_pcs pcs;
+};
+
+static struct airoha_pcs_port *phylink_pcs_to_airoha_pcs_port(struct phylink_pcs *pcs)
+{
+	return container_of(pcs, struct airoha_pcs_port, pcs);
+}
+
+static void airoha_pcs_rx_calib(struct airoha_pcs_priv *priv,
+				phy_interface_t interface)
+{
+	int turn_pr_idac_bit_position;
+	unsigned int FL_Out_target;
+	unsigned int PrCal_Serach;
+	int cdr_pr_idac_tmp = 0;
+	unsigned int cyclecnt;
+
+	/* FOR FULL CALIBRATION REFER TO air_eth_xsgmii LINE 1668 */
+	switch (interface) {
+	case PHY_INTERFACE_MODE_USXGMII: /* DS_10.3125G  /  US_1.25G */
+		FL_Out_target = 0x9EDF;
+		cyclecnt = 32767;
+		break;
+	default:
+		return;
+	}
+
+	regmap_set_bits(priv->xfi_pma, PHYD_SW_RST_SET, BIT(5));
+
+	regmap_update_bits(priv->xfi_pma, PHYD_SS_RX_FREQ_DET_2,
+		     GENMASK(31, 16) | GENMASK(15, 0),
+		     FIELD_PREP(GENMASK(31, 16), FL_Out_target + 100) |
+		     FIELD_PREP(GENMASK(15, 0), FL_Out_target - 100));
+
+	regmap_update_bits(priv->xfi_pma, PHYD_SS_RX_FREQ_DET_1,
+		     GENMASK(31, 16) | GENMASK(15, 0),
+		     FIELD_PREP(GENMASK(31, 16), cyclecnt) |
+		     FIELD_PREP(GENMASK(15, 0), cyclecnt));
+
+	regmap_update_bits(priv->xfi_pma, PHYD_SS_RX_FREQ_DET_4,
+		     GENMASK(15, 12) | GENMASK(11, 8),
+		     FIELD_PREP(GENMASK(15, 12), 3) |
+		     FIELD_PREP(GENMASK(11, 8), 3));
+
+	regmap_update_bits(priv->xfi_pma, PHYD_SS_RX_FREQ_DET_3,
+		     GENMASK(31, 16) | GENMASK(15, 0),
+		     FIELD_PREP(GENMASK(31, 16), FL_Out_target + 100) |
+		     FIELD_PREP(GENMASK(15, 0), FL_Out_target - 100));
+
+	regmap_set_bits(priv->xfi_ana, PHYA_PXP_CDR_PR_INJ_MODE, BIT(24));
+
+	regmap_update_bits(priv->xfi_pma, PHYD_FORCE_DA_PXP_CDR_PR_LPF,
+			   BIT(24) | BIT(16) | BIT(8) | BIT(0),
+			   BIT(24) | BIT(16) | BIT(8));
+
+	regmap_set_bits(priv->xfi_pma, PHYD_FORCE_DA_PXP_CDR_PR_IDAC,
+			BIT(16));
+
+	regmap_set_bits(priv->xfi_pma, PHYD_FORCE_DA_PXP_CDR_PR_PIEYE_PWDB,
+			BIT(8));
+
+	regmap_clear_bits(priv->xfi_pma, PHYD_FORCE_DA_PXP_CDR_PR_PIEYE_PWDB,
+			BIT(0));
+
+	regmap_set_bits(priv->xfi_pma, PHYD_FORCE_DA_PXP_CDR_PR_PIEYE_PWDB,
+			BIT(0));
+
+	for (PrCal_Serach = 1; PrCal_Serach < 8 ; PrCal_Serach++) {
+		unsigned int RO_FL_Out;
+		u32 val;
+
+		/* try to find the upper value by setting the last 3 bit */
+		regmap_update_bits(priv->xfi_pma, PHYD_FORCE_DA_PXP_CDR_PR_IDAC,
+				   GENMASK(10, 0),
+				   FIELD_PREP(GENMASK(10, 8), PrCal_Serach));
+
+		regmap_update_bits(priv->xfi_pma, PHYD_SS_RX_FREQ_DET_4,
+				   GENMASK(2, 0),
+				   FIELD_PREP(GENMASK(2, 0), 0));
+
+		regmap_update_bits(priv->xfi_pma, PHYD_SS_RX_FREQ_DET_4,
+				   GENMASK(2, 0),
+				   FIELD_PREP(GENMASK(2, 0), 3));
+
+		usleep_range(5000, 7000);
+
+		regmap_read(priv->xfi_pma, PHYD_RX_FREQDET, &val);
+
+		RO_FL_Out = FIELD_GET(GENMASK(31, 16), val);
+		if (RO_FL_Out > FL_Out_target)
+			cdr_pr_idac_tmp = FIELD_PREP(GENMASK(10, 8), PrCal_Serach);
+	}
+
+	for (turn_pr_idac_bit_position = 7; turn_pr_idac_bit_position > -1 ; turn_pr_idac_bit_position--) {
+		unsigned int pr_idac;
+		u32 val;
+
+		pr_idac = cdr_pr_idac_tmp | BIT(turn_pr_idac_bit_position);
+
+		regmap_update_bits(priv->xfi_pma, PHYD_FORCE_DA_PXP_CDR_PR_IDAC,
+				   GENMASK(10, 0),
+				   FIELD_PREP(GENMASK(10, 0), pr_idac));
+
+		regmap_update_bits(priv->xfi_pma, PHYD_SS_RX_FREQ_DET_4,
+				   GENMASK(2, 0),
+				   FIELD_PREP(GENMASK(2, 0), 0));
+
+		regmap_update_bits(priv->xfi_pma, PHYD_SS_RX_FREQ_DET_4,
+				   GENMASK(2, 0),
+				   FIELD_PREP(GENMASK(2, 0), 3));
+
+		usleep_range(5000, 7000);
+
+		regmap_read(priv->xfi_pma, PHYD_RX_FREQDET, &val);
+
+		unsigned int RO_FL_Out = FIELD_GET(GENMASK(31, 16), val);
+
+		if (RO_FL_Out < FL_Out_target)
+			pr_idac &= ~BIT(turn_pr_idac_bit_position);
+
+		cdr_pr_idac_tmp = pr_idac;
+	}
+
+	regmap_write(priv->xfi_pma, PHYD_FORCE_DA_PXP_CDR_PR_IDAC, cdr_pr_idac_tmp);
+
+	regmap_update_bits(priv->xfi_pma, PHYD_SS_RX_FREQ_DET_4,
+				   GENMASK(2, 0),
+				   FIELD_PREP(GENMASK(2, 0), 0));
+
+	regmap_update_bits(priv->xfi_pma, PHYD_SS_RX_FREQ_DET_4,
+				GENMASK(2, 0),
+				FIELD_PREP(GENMASK(2, 0), 3));
+
+	usleep_range(5000, 7000);
+
+	/* Load_Band */
+
+	/* rg_pxp_cdr_pr_inj_force_off */
+	regmap_clear_bits(priv->xfi_ana, PHYA_PXP_CDR_PR_INJ_MODE, BIT(24));
+
+	regmap_update_bits(priv->xfi_pma, PHYD_FORCE_DA_PXP_CDR_PR_PIEYE_PWDB,
+			BIT(0) | BIT(8) | BIT(16) | BIT(24),
+			BIT(16) | BIT(24));
+
+	regmap_clear_bits(priv->xfi_pma, PHYD_FORCE_DA_PXP_CDR_PR_IDAC, BIT(16));
+
+	regmap_set_bits(priv->xfi_pma, PHYD_SS_RX_FLL_b, BIT(0));
+
+	regmap_update_bits(priv->xfi_pma, PHYD_SS_RX_FLL_1, GENMASK(10, 0),
+			   FIELD_PREP(GENMASK(10, 0), cdr_pr_idac_tmp));
+
+	regmap_clear_bits(priv->xfi_pma, PHYD_FORCE_DA_PXP_CDR_PR_PIEYE_PWDB, BIT(16));
+
+	regmap_set_bits(priv->xfi_pma, PHYD_FORCE_DA_PXP_CDR_PR_PIEYE_PWDB, BIT(16));
+
+	regmap_clear_bits(priv->xfi_pma, PHYD_FORCE_DA_PXP_CDR_PR_PIEYE_PWDB, BIT(24));
+
+	regmap_set_bits(priv->xfi_pma, PHYD_SW_RST_SET, BIT(16));
+}
+
+static void airoha_pcs_get_state_usxgmii(struct airoha_pcs_priv *priv,
+					 struct phylink_link_state *state)
+{
+	int i, count = 0;
+	u32 val;
+
+	/* TODO ask for a better way to check link up, NOT reliable */
+	regmap_write(priv->xfi_pma, PHYD_RESERVE_0, 0x30000);
+	for (i = 0; i < 6; i++) {
+		regmap_read(priv->xfi_pma, PHYD_RESERVE_2, &val);
+		if (val & BIT(8))
+			count++;
+	}
+
+	state->link = count >= 4;
+	if (!state->link)
+		return;
+
+	regmap_read(priv->usxgmii, HSGMII_USXGMII_AN_STATS_2, &val);
+	state->an_complete = !!(val & BIT(24));
+
+	/* TODO no way to check duplex wait Airoha feedback */
+	state->duplex = DUPLEX_FULL;
+
+	regmap_set_bits(priv->usxgmii, HSGMII_USXGMII_AN_CONTROL_6, BIT(0));
+	regmap_clear_bits(priv->usxgmii, HSGMII_USXGMII_AN_CONTROL_6, BIT(0));
+
+	regmap_read(priv->usxgmii, HSGMII_USXGMII_AN_STATS_0, &val);
+
+	switch (FIELD_GET(GENMASK(30, 28), val)) {
+	case 0:
+		state->speed = SPEED_10000;
+		break;
+	case 1:
+		state->speed = SPEED_5000;
+		break;
+	case 2:
+		state->speed = SPEED_2500;
+		break;
+	case 3:
+		state->speed = SPEED_1000;
+		break;
+	case 4:
+		state->speed = SPEED_100;
+		break;
+	}
+
+	/* TODO check if this is ok to do */
+	regmap_read(priv->xfi_mac, XFI_MAC_GIB_CFG, &val);
+
+	if (val & BIT(5))
+		state->pause |= MLO_PAUSE_TX;
+
+	if (val & BIT(4))
+		state->pause |= MLO_PAUSE_RX;
+
+	return;
+}
+
+static int airoha_pcs_setup_usxgmii(struct airoha_pcs_priv *priv)
+{
+	/* xsgmii_chg 1 */
+	regmap_update_bits(priv->scu, SCU_SSR3, GENMASK(14, 13), BIT(13));
+
+	regmap_write(priv->xfi_ana, PHYA_PXP_CMN_EN, 0x10040001);
+
+	//b'JCPLL BringUp 0\r\n'
+	//b'JCPLL_LDO\r\n'
+	regmap_write(priv->xfi_ana, PHYA_JCPLL_LDO, 0x1020ff);
+
+	/* JCPLL_RSTB */
+	regmap_write(priv->xfi_ana, PHYA_JCPLL_RSTB, 0x3000004);
+	regmap_write(priv->xfi_ana, PHYA_JCPLL_RSTB, 0x3000104);
+
+	/* JCPLL_EN */
+	regmap_write(priv->xfi_pma, PHYD_JCPLL_EN, 0x1000000);
+
+	/* JCPLL_SDM */
+	regmap_write(priv->xfi_ana, PHYA_JCPLL_RSTB, 0x104);
+	regmap_write(priv->xfi_ana, PHYA_JCPLL_SDM1, 0x30000);
+	regmap_write(priv->xfi_ana, PHYA_JCPLL_SDM2, 0x5010100);
+
+	/* JCPLL_SSC */
+	regmap_write(priv->xfi_ana, PHYA_JCPLL_SSC3, 0x0);
+	regmap_write(priv->xfi_ana, PHYA_JCPLL_SSC2, 0x0);
+	regmap_write(priv->xfi_ana, PHYA_JCPLL_SSC1, 0x3018);
+
+	/* JCPLL_LPF */
+	regmap_write(priv->xfi_ana, PHYA_JCPLL_LPF1, 0x180000);
+	regmap_write(priv->xfi_ana, PHYA_JCPLL_LPF2, 0x101f0a);
+	regmap_write(priv->xfi_ana, PHYA_JCPLL_LPF3, 0x2ff0000);
+
+	/* JCPLL_VCO */
+	regmap_write(priv->xfi_ana, PHYA_JCPLL_VCO, 0x4010100);
+	regmap_write(priv->xfi_ana, PHYA_JCPLL_SSC1, 0x301b); /* TODO CHECK */
+
+	/* JCPLL_PCW */
+	regmap_write(priv->xfi_pma, PHYD_JCPLL_PCW2, 0x25800000);
+	regmap_write(priv->xfi_pma, PHYD_JCPLL_PCW1, 0x10000);
+
+	/* JCPLL_DIV */
+	regmap_write(priv->xfi_ana, PHYA_JCPLL_DIV, 0x10000);
+	regmap_write(priv->xfi_ana, PHYA_JCPLL_VCO, 0x4010100);
+
+	/* JCPLL_KBand */
+	regmap_write(priv->xfi_ana, PHYA_JCPLL_KBand, 0x1000300);
+	regmap_write(priv->xfi_ana, PHYA_JCPLL_LPF3, 0x2e40000);
+
+	/* JCPLL_TCL */
+	regmap_write(priv->xfi_ana, PHYA_JCPLL_LDO, 0xf20ff);
+	regmap_write(priv->xfi_ana, PHYA_JCPLL_SDM2, 0x5010100);
+	regmap_write(priv->xfi_ana, PHYA_JCPLL_TCL2, 0x1010400); /* TODO CHECK */
+
+	/* JCPLL_EN */
+	regmap_write(priv->xfi_pma, PHYD_JCPLL_EN, 0x1010000);
+
+	/* JCPLL_Out */
+	regmap_write(priv->xfi_pma, PHYD_JCPLL_EN, 0x1010101);
+
+	/* TXPLL BringUp */
+	/* TXPLL_VCOLDO_Out */
+	regmap_write(priv->xfi_ana, PHYA_TXPLL_VCOLDO_Out, 0x101031b);
+
+	/* TXPLL_RSTB */
+	regmap_write(priv->xfi_ana, PHYA_TXPLL_RSTB, 0x1040001);
+
+	/* TXPLL_EN */
+	regmap_write(priv->xfi_pma, PHYD_TXPLL_EN, 0x1000000);
+
+	/* TXPLL_SDM */
+	regmap_write(priv->xfi_ana, PHYA_TXPLL_SDM1, 0x0);
+	regmap_write(priv->xfi_ana, PHYA_TXPLL_SDM2, 0x1010003);
+
+	/* TXPLL_SSC */
+	regmap_write(priv->xfi_ana, PHYA_TXPLL_SSC1, 0x0);
+	regmap_write(priv->xfi_ana, PHYA_TXPLL_SSC2, 0x0);
+	regmap_write(priv->xfi_ana, PHYA_TXPLL_VCOLDO_Out, 0x1010000);
+
+	/* TXPLL_LPF */
+	regmap_write(priv->xfi_ana, PHYA_TXPLL_LPF1, 0x1f05000f);
+	regmap_write(priv->xfi_ana, PHYA_TXPLL_LPF2, 0x180b02);
+
+	/* TXPLL_VCO */
+	regmap_write(priv->xfi_ana, PHYA_TXPLL_VCO1, 0x1000001);
+	regmap_write(priv->xfi_ana, PHYA_TXPLL_VCO2, 0x4040701);
+
+	/* TXPLL_PCW */
+	regmap_write(priv->xfi_pma, PHYD_FORCE_DA_PXP_TXPLL_SDM_PCW, 0x8400000); /* TODO DIFFER FROM BL */
+	regmap_write(priv->xfi_pma, PHYD_FORCE_DA_PXP_CDR_PR_IDAC, 0x1000000);
+
+	/* TXPLL_KBand */
+	regmap_write(priv->xfi_ana, PHYA_TXPLL_KBand1, 0x30004e4);
+	regmap_write(priv->xfi_ana, PHYA_TXPLL_KBand2, 0x101);
+	regmap_write(priv->xfi_ana, PHYA_TXPLL_LPF2, 0x180b02);
+
+	/* TXPLL_DIV */
+	regmap_write(priv->xfi_ana, PHYA_TXPLL_KBand2, 0x1);
+	regmap_write(priv->xfi_ana, PHYA_TXPLL_VCO1, 0x1000001);
+
+	/* TXPLL_TCL */
+	regmap_write(priv->xfi_ana, PHYA_TXPLL_PCW1, 0x1000f);
+	regmap_write(priv->xfi_ana, PHYA_TXPLL_TCL, 0x4000b03);
+	regmap_write(priv->xfi_ana, PHYA_TXPLL_VCO1, 0x1000001);
+	regmap_write(priv->xfi_ana, PHYA_TXPLL_SDM2, 0x1010003);
+
+	/* TXPLL_EN */
+	regmap_write(priv->xfi_pma, PHYD_TXPLL_EN, 0x1010000);
+
+	/* TXPLL_Out */
+	regmap_write(priv->xfi_pma, PHYD_TXPLL_EN, 0x1010101);
+
+	/* TX BringUp 1 */
+	/* tx_rate_ctrl 1 */
+	regmap_write(priv->xfi_pma, PHYD_tx_rate_ctrl, 0x2);
+
+	/* TX_CONFIG */
+	regmap_write(priv->xfi_ana, PHYA_TX_CONFIG1, 0x1010401);
+	regmap_write(priv->xfi_pma, PHYD_TX_CONFIG2, 0x1010000);
+	regmap_write(priv->xfi_pma, PHYD_TX_CONFIG3, 0x1050000);
+	regmap_write(priv->xfi_pma, PHYD_TX_CONFIG4, 0x102);
+
+	//b'TX_FIR_Load_Para swing 2, len 4, cn1 1, c0b 1, c1 b, en 1\r\n'
+	//b'TX_FIR\r\n'
+	regmap_write(priv->xfi_pma, PHYD_TX_FIR1, 0x1010101);
+	regmap_write(priv->xfi_pma, PHYD_TX_FIR2, 0x10b);
+
+	/* TX_RSTB */
+	regmap_write(priv->xfi_pma, PHYD_TX_RSTB, 0x101);
+
+	//b'RX BringUp 0\r\n'
+	//b'RX_INIT\r\n'
+	//b'rx_rate_ctrl\r\n'
+	regmap_write(priv->xfi_pma, PHYD_rx_rate_ctrl, 0x2);
+
+	regmap_write(priv->xfi_pma, PHYD_RX_Path_Init1, 0x40003ff);
+	regmap_write(priv->xfi_ana, PHYA_RX_Path_Init2, 0x1010101);
+	regmap_write(priv->xfi_ana, PHYA_RX_Path_Init3, 0x1000000);
+	regmap_write(priv->xfi_ana, PHYA_RX_Path_Init4, 0x2000401);
+	regmap_write(priv->xfi_pma, PHYD_RX_Path_Init5, 0xc100a01);
+	regmap_write(priv->xfi_ana, PHYA_RX_Path_Init6, 0x20000);
+	regmap_write(priv->xfi_ana, PHYA_RX_Path_Init7, 0x3ff08);
+	regmap_write(priv->xfi_pma, PHYD_RX_Path_Init8, 0x10101);
+	regmap_write(priv->xfi_pma, PHYD_RX_Path_Init9, 0x1000202);
+	regmap_write(priv->xfi_ana, PHYA_RX_Path_Init10, 0x0);
+	regmap_write(priv->xfi_pma, PHYD_RX_Path_Init11, 0x1000000);
+	regmap_write(priv->xfi_pma, PHYD_RX_Path_Init12, 0x1010000);
+	regmap_write(priv->xfi_ana, PHYA_RX_Path_Init13, 0x70604);
+
+	//b'RX_FE,force 0, Gain 1, Peaking 2\r\n'
+	regmap_write(priv->xfi_pma, PHYD_RX_FE1, 0x0);
+	regmap_write(priv->xfi_pma, PHYD_RX_FE2, 0x0);
+
+	/* RX_FE_VOS */
+	regmap_write(priv->xfi_pma, PHYD_RX_FE_VOS, 0x10000);
+
+	/* RX_IMP 1 */
+	regmap_write(priv->xfi_ana, PHYA_RX_IMP, 0x1040000);
+
+	/* RX_FLL_PR_FMeter */
+	regmap_write(priv->xfi_ana, PHYA_RX_FLL_PR_FMeter1, 0x100001);
+	regmap_write(priv->xfi_ana, PHYA_RX_FLL_PR_FMeter2, 0xffff0000);
+	regmap_write(priv->xfi_ana, PHYA_RX_FLL_PR_FMeter3, 0x3107);
+
+	/* RX_REV */
+	regmap_write(priv->xfi_ana, PHYA_RX_REV, 0xc8c31030);
+
+	/* RX_Rdy_TimeOut */
+	regmap_write(priv->xfi_pma, PHYD_RX_Rdy_TimeOut, 0xa0005);
+
+	/* RX_CalBoundry_Init */
+	regmap_write(priv->xfi_pma, PHYD_RX_CalBoundry_Init1, 0x101);
+	regmap_write(priv->xfi_pma, PHYD_RX_CalBoundry_Init2, 0x2);
+	regmap_write(priv->xfi_pma, PHYD_RX_CalBoundry_Init3, 0x320002);
+	regmap_write(priv->xfi_pma, PHYD_RX_CalBoundry_Init4, 0xff0002);
+	regmap_write(priv->xfi_pma, PHYD_RX_CalBoundry_Init5, 0x320002);
+	regmap_write(priv->xfi_pma, PHYD_RX_CalBoundry_Init6, 0x320002);
+
+	/* RX_BySerdes */
+	/* RX_OSR */
+	regmap_write(priv->xfi_pma, PHYD_RX_OSR, 0x1000000);
+	regmap_write(priv->xfi_ana, PHYA_RX_Path_Init10, 0x0);
+
+	/* CDR_LPF_RATIO */
+	regmap_write(priv->xfi_ana, PHYA_CDR_LPF_RATIO, 0x2000000);
+
+	/* CDR_PR */
+	regmap_write(priv->xfi_ana, PHYA_CDR_PR1, 0x4010808);
+	regmap_write(priv->xfi_ana, PHYA_CDR_PR2, 0x80606);
+
+	/* RX_EYE_Mon */
+	regmap_write(priv->xfi_pma, PHYD_RX_EYE_Mon1, 0x103);
+	regmap_write(priv->xfi_pma, PHYD_RX_EYE_Mon2, 0x1);
+
+	/* RX_SYS_En */
+	regmap_write(priv->xfi_pma, PHYD_RX_SYS_En1, 0x1);
+	regmap_write(priv->xfi_pma, PHYD_RX_SYS_En2, 0x1000000);
+
+	/* RX_FLL_PR_FMeter */
+	regmap_write(priv->xfi_pma, PHYD_RX_FLL_PR_FMeter1, 0x1010100);
+	regmap_write(priv->xfi_pma, PHYD_RX_FLL_PR_FMeter2, 0x1);
+
+	/* RX_CMLEQ_EN */
+	regmap_write(priv->xfi_ana, PHYA_RX_CMLEQ_EN, 0x1010100);
+
+	/* RX_CDR_PR */
+	regmap_write(priv->xfi_ana, PHYA_RX_Path_Init13, 0x70604);
+
+	/* RX_CDR_xxx_Pwdb */
+	regmap_write(priv->xfi_pma, PHYD_RX_CDR_xxx_Pwdb1, 0x1000100);
+	regmap_write(priv->xfi_pma, PHYD_RX_CDR_xxx_Pwdb2, 0x100);
+	regmap_write(priv->xfi_pma, PHYD_RX_CDR_xxx_Pwdb3, 0x100);
+	regmap_write(priv->xfi_pma, PHYD_RX_CDR_xxx_Pwdb4, 0x1000000);
+	regmap_write(priv->xfi_pma, PHYD_RX_CDR_xxx_Pwdb5, 0x0);
+
+	/* RX_SigDet */
+	regmap_write(priv->xfi_ana, PHYA_RX_IMP, 0x20200); /* TODO CHECK */
+	regmap_write(priv->xfi_ana, PHYA_RX_SigDet, 0x3000200);
+
+	/* RX_SigDet_Pwdb */
+	regmap_write(priv->xfi_pma, PHYD_RX_SigDet_Pwdb, 0x0);
+
+	/* PXP_RX_PHYCK */
+	regmap_write(priv->xfi_ana, PHYA_PXP_RX_PHYCK1, 0x10242);
+	regmap_write(priv->xfi_ana, PHYA_PXP_RX_PHYCK2, 0x1000000);
+
+	/* RX_CDR_xxx_Pwdb */
+	regmap_write(priv->xfi_pma, PHYD_RX_CDR_xxx_Pwdb1, 0x1010101);
+	regmap_write(priv->xfi_pma, PHYD_RX_CDR_xxx_Pwdb2, 0x101);
+	regmap_write(priv->xfi_pma, PHYD_RX_CDR_xxx_Pwdb3, 0x101);
+	regmap_write(priv->xfi_pma, PHYD_RX_CDR_xxx_Pwdb4, 0x1010000);
+	regmap_write(priv->xfi_pma, PHYD_RX_CDR_xxx_Pwdb5, 0x1010101);
+
+	/* RX_SigDet_Pwdb */
+	regmap_write(priv->xfi_pma, PHYD_RX_SigDet_Pwdb, 0x1);
+
+	/* RX_PR_CAL_SEQ 1 */
+	/* RX_CDR_LFP_L2D mode 1, sel 0*/
+	regmap_write(priv->xfi_pma, PHYD_RX_CDR_LFP_L2D, 0x100);
+
+	airoha_pcs_rx_calib(priv, PHY_INTERFACE_MODE_USXGMII);
+
+	/* RX_PRCal_end */
+
+	/* RX_CDR_LPF_RSTB mode 1, sel0 */
+	regmap_write(priv->xfi_pma, PHYD_RX_CDR_LFP_L2D, 0x1000100);
+
+	usleep_range(700, 1000);
+
+	/* RX_CDR_LPF_RSTB mode 1, sel1 */
+	regmap_write(priv->xfi_pma, PHYD_RX_CDR_LFP_L2D, 0x1010100);
+
+	usleep_range(100, 200);
+
+	/* RX_CDR_LFP_L2D mode 1, sel 1 */
+	regmap_write(priv->xfi_pma, PHYD_RX_CDR_LFP_L2D, 0x1010101);
+
+	/* RX_CDR_LPF_RSTB mode 0, sel1 */
+	regmap_write(priv->xfi_pma, PHYD_RX_CDR_LFP_L2D, 0x10101);
+	regmap_write(priv->xfi_pma, PHYD_RX_CDR_LFP_L2D, 0x10001);
+
+	/* RSTB sel8, val 0 */
+	regmap_write(priv->xfi_pma, PHYD_RX_PRCal1, 0x20);
+	/* RSTB sel8, val 1 */
+	regmap_write(priv->xfi_pma, PHYD_RX_PRCal1, 0xfff);
+
+	/* RX_CDR_RST */
+
+	/* RX_CDR_LFP_L2D mode 1, sel 0 */
+	regmap_write(priv->xfi_pma, PHYD_RX_CDR_LFP_L2D, 0x10100);
+	/* RX_CDR_LPF_RSTB mode 1, sel0 */
+	regmap_write(priv->xfi_pma, PHYD_RX_CDR_LFP_L2D, 0x1000100);
+
+	usleep_range(700, 1000);
+
+	/* RX_CDR_LPF_RSTB mode 1, sel1 */
+	regmap_write(priv->xfi_pma, PHYD_RX_CDR_LFP_L2D, 0x1010100);
+
+	usleep_range(100, 200);
+
+	/* RX_CDR_LFP_L2D mode 1, sel 1 */
+	regmap_write(priv->xfi_pma, PHYD_RX_CDR_LFP_L2D, 0x1010101);
+
+	/* RX_CDR_LPF_RSTB mode 0, sel1 */
+	regmap_write(priv->xfi_pma, PHYD_RX_CDR_LFP_L2D, 0x10101);
+
+	/* RX_CDR_LFP_L2D mode 0, sel 1 */
+	regmap_write(priv->xfi_pma, PHYD_RX_CDR_LFP_L2D, 0x10001);
+
+	//b'xSGMII_Solution : 0\r\n'
+	//b'xsgmii_init\r\n'
+	//b'usxgmii_init 1\r\n'
+	regmap_write(priv->multi_sgmii, HSGMII_USXGMII_INIT, 0x10010001); /* set bit 28 */
+
+	regmap_clear_bits(priv->usxgmii, HSGMII_PCS_CTROL_1, BIT(13));
+
+	//b'PCS E0/E1 solution\r\n'
+	/* TODO Seems to be a workaround for some SoC, need to ask Airoha */
+	regmap_write(priv->usxgmii, HSGMII_USXGMII_PCS_E0E1, 0x0);
+
+	//b'usxgmii_pcs_int en 0\r\n'
+	regmap_write(priv->usxgmii, HSGMII_USXGMII_INT_EN1, 0x0);
+	regmap_write(priv->usxgmii, HSGMII_USXGMII_INT_EN2, 0x0);
+	regmap_write(priv->usxgmii, HSGMII_USXGMII_INT_EN3, 0x0);
+	regmap_write(priv->usxgmii, HSGMII_USXGMII_INT_EN4, 0x0);
+	regmap_write(priv->usxgmii, HSGMII_USXGMII_INT_EN5, 0x0);
+	regmap_write(priv->usxgmii, HSGMII_USXGMII_INT_EN6, 0x0);
+	regmap_write(priv->usxgmii, HSGMII_USXGMII_INT_EN7, 0x0);
+	regmap_write(priv->usxgmii, HSGMII_USXGMII_INT_EN8, 0x0);
+	regmap_write(priv->usxgmii, HSGMII_USXGMII_INT_EN9, 0x0);
+	regmap_write(priv->usxgmii, HSGMII_USXGMII_INT_EN10, 0x0);
+	regmap_write(priv->usxgmii, HSGMII_USXGMII_INT_EN11, 0x0);
+
+	//b'xsgmii 0 int enable 0\r\n'
+	//b'AN mode\r\n'
+	regmap_write(priv->hsgmii_an, HSGMII_SGMII_AN, 0x1140);
+
+	//b'xSGMII_AN_API 0, enable : 1\r\n'
+	//b'usxgmii_an\r\n'
+	regmap_write(priv->usxgmii, HSGMII_USXGMII_AN_EN, 0x6330001);
+
+	//b'_rg_usxgmii_an_control_0 6330001\r\n'
+	//b'_rg_usxgmii_an_control_1 0\r\n'
+	//b'xSGMII_AN_AutoSetting\r\n'
+	regmap_write(priv->hsgmii_rate_adp, HSGMII_HSGMII_25G, 0x0000c11); /* TODO last c not set in USXGMII but in XFI */
+	regmap_write(priv->hsgmii_rate_adp, HSGMII_HSGMII_XFI, 0x4); /* TODO FROM BL XFI BIT(8) in XFI but no USXGMII */
+
+	/* make sure these are correct as BL might set these */
+	regmap_write(priv->hsgmii_pcs, HSGMII_XSGMII_INIT, 0xc9cc000); /* TODO CHECK bit30 is set in BL */
+	regmap_write(priv->multi_sgmii, HSGMII_HSGMII_INIT, 0x0); /* TODO set force speed bit in BL */
+
+	return 0;
+}
+
+static void airoha_pcs_get_state(struct phylink_pcs *pcs,
+				 struct phylink_link_state *state)
+{
+	struct airoha_pcs_port *port = phylink_pcs_to_airoha_pcs_port(pcs);
+
+	/* TODO state for SGMII, HSGMII seems to only support fixed link 2.5g */
+	switch (state->interface) {
+	case PHY_INTERFACE_MODE_USXGMII:
+		airoha_pcs_get_state_usxgmii(port->priv, state);
+		return;
+	default:
+		return;
+	}
+}
+
+static int airoha_pcs_config(struct phylink_pcs *pcs, unsigned int neg_mode,
+			     phy_interface_t interface,
+			     const unsigned long *advertising,
+			     bool permit_pause_to_mac)
+{
+	struct airoha_pcs_port *port = phylink_pcs_to_airoha_pcs_port(pcs);
+
+	switch (interface) {
+	case PHY_INTERFACE_MODE_USXGMII:
+		return airoha_pcs_setup_usxgmii(port->priv);
+	/* TODO Rework code new pcs struct mapping */
+	// case PHY_INTERFACE_MODE_2500BASEX:
+	// 	return airoha_pcs_setup_hsgmii(pcs);
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static void airoha_pcs_an_restart(struct phylink_pcs *pcs)
+{
+	/* TODO can be supported for USXGMII and maybe SGMII */
+	return;
+}
+
+static const struct phylink_pcs_ops airoha_pcs_ops = {
+	//.pcs_inband_caps = airoha_pcs_inband_caps,
+	.pcs_get_state = airoha_pcs_get_state,
+	.pcs_config = airoha_pcs_config,
+	.pcs_an_restart = airoha_pcs_an_restart,
+};
+
+struct phylink_pcs *airoha_pcs_create(struct device *dev)
+{
+	struct platform_device *pdev;
+	struct airoha_pcs_port *port;
+	struct device_node *np;
+
+	np = of_parse_phandle(dev->of_node, "pcs", 0);
+	if (!np)
+		return ERR_PTR(-ENODEV);
+
+	if (!of_device_is_available(np)) {
+		of_node_put(np);
+		return ERR_PTR(-ENODEV);
+	}
+
+	pdev = of_find_device_by_node(np);
+	of_node_put(np);
+	if (!pdev || !platform_get_drvdata(pdev)) {
+		if (pdev)
+			put_device(&pdev->dev);
+		return ERR_PTR(-EPROBE_DEFER);
+	}
+
+	port = kzalloc(sizeof(*port), GFP_KERNEL);
+	if (!port)
+		return ERR_PTR(-ENOMEM);
+
+	port->priv = platform_get_drvdata(pdev);
+	port->pcs.ops = &airoha_pcs_ops;
+	port->pcs.neg_mode = true;
+	port->pcs.poll = true;
+
+	return &port->pcs;
+}
+EXPORT_SYMBOL(airoha_pcs_create);
+
+void airoha_pcs_destroy(struct phylink_pcs *pcs)
+{
+	struct airoha_pcs_port *port = phylink_pcs_to_airoha_pcs_port(pcs);
+
+	kfree(port);
+}
+EXPORT_SYMBOL(airoha_pcs_destroy);
+
+static const struct regmap_config airoha_pcs_regmap_config = {
+	.reg_bits = 32,
+	.val_bits = 32,
+	.reg_stride = 4,
+};
+
+static int airoha_pcs_probe(struct platform_device *pdev) {
+	struct regmap_config syscon_config = airoha_pcs_regmap_config;
+	struct device *dev = &pdev->dev;
+	struct airoha_pcs_priv *priv;
+	void *base;
+
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	base = devm_platform_ioremap_resource_byname(pdev, "xfi_mac");
+	if (IS_ERR(base))
+		return PTR_ERR(base);
+
+	syscon_config.name = "xfi_mac";
+	priv->xfi_mac = devm_regmap_init_mmio(dev, base, &syscon_config);
+	if (IS_ERR(priv->xfi_mac))
+		return PTR_ERR(priv->xfi_mac);
+
+	base = devm_platform_ioremap_resource_byname(pdev, "hsgmii_an");
+	if (IS_ERR(base))
+		return PTR_ERR(base);
+
+	syscon_config.name = "hsgmii_an";
+	priv->hsgmii_an = devm_regmap_init_mmio(dev, base, &syscon_config);
+	if (IS_ERR(priv->hsgmii_an))
+		return PTR_ERR(priv->hsgmii_an);
+
+	base = devm_platform_ioremap_resource_byname(pdev, "hsgmii_pcs");
+	if (IS_ERR(base))
+		return PTR_ERR(base);
+
+	syscon_config.name = "hsgmii_pcs";
+	priv->hsgmii_pcs = devm_regmap_init_mmio(dev, base, &syscon_config);
+	if (IS_ERR(priv->hsgmii_pcs))
+		return PTR_ERR(priv->hsgmii_pcs);
+
+	/* TODO conclicts with XFI-ANA */
+	// base = devm_platform_ioremap_resource_byname(pdev, "hsgmii_analog");
+	// if (IS_ERR(base))
+	// 	return PTR_ERR(base);
+
+	// syscon_config.name = "hsgmii_analog";
+	// priv->hsgmii_analog = devm_regmap_init_mmio(dev, base, &syscon_config);
+	// if (IS_ERR(priv->hsgmii_analog))
+	// 	return PTR_ERR(priv->hsgmii_analog);
+
+	base = devm_platform_ioremap_resource_byname(pdev, "hsgmii_rate_adp");
+	if (IS_ERR(base))
+		return PTR_ERR(base);
+
+	syscon_config.name = "hsgmii_rate_adp";
+	priv->hsgmii_rate_adp = devm_regmap_init_mmio(dev, base, &syscon_config);
+	if (IS_ERR(priv->hsgmii_rate_adp))
+		return PTR_ERR(priv->hsgmii_rate_adp);
+
+	base = devm_platform_ioremap_resource_byname(pdev, "multi_sgmii");
+	if (IS_ERR(base))
+		return PTR_ERR(base);
+
+	syscon_config.name = "multi_sgmii";
+	priv->multi_sgmii = devm_regmap_init_mmio(dev, base, &syscon_config);
+	if (IS_ERR(priv->multi_sgmii))
+		return PTR_ERR(priv->multi_sgmii);
+
+	/* For USB PCS usxgmii is not supported and it's optional */
+	base = devm_platform_ioremap_resource_byname(pdev, "usxgmii");
+	if (IS_ERR(base) && PTR_ERR(base) != -ENOENT)
+		return PTR_ERR(base);
+
+	if (!IS_ERR(base)) {
+		syscon_config.name = "usxgmii";
+		priv->usxgmii = devm_regmap_init_mmio(dev, base, &syscon_config);
+		if (IS_ERR(priv->usxgmii))
+			return PTR_ERR(priv->usxgmii);
+	}
+
+	/* XFI PMA and ANA are for xfi port only and are optional for other modes */
+	priv->xfi_pma = syscon_regmap_lookup_by_phandle(dev->of_node, "airoha,xfi-pma");
+	if (IS_ERR(priv->xfi_pma) && PTR_ERR(base) != -ENOENT)
+		return PTR_ERR(priv->xfi_pma);
+
+	priv->xfi_ana = syscon_regmap_lookup_by_phandle(dev->of_node, "airoha,xfi-ana");
+	if (IS_ERR(priv->xfi_ana) && PTR_ERR(base) != -ENOENT)
+		return PTR_ERR(priv->xfi_ana);
+
+	/* SCU is used to toggle XFI or HSGMII in global SoC registers */
+	priv->scu = syscon_regmap_lookup_by_compatible("airoha,en7581-scu");
+	if (IS_ERR(priv->scu))
+		return PTR_ERR(priv->scu);
+
+	platform_set_drvdata(pdev, priv);
+
+	return 0;
+}
+
+static const struct of_device_id airoha_pcs_of_table[] = {
+	{ .compatible = "airoha,an7581-pcs" },
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(of, airoha_pcs_of_table);
+
+static struct platform_driver airoha_pcs_driver = {
+	.driver = {
+		.name	 = "airoha-pcs",
+		.of_match_table = airoha_pcs_of_table,
+	},
+	.probe = airoha_pcs_probe,
+};
+module_platform_driver(airoha_pcs_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Airoha PCS driver");
+MODULE_AUTHOR("Christian Marangi <ansuelsmth@gmail.com>");
\ No newline at end of file
--- /dev/null
+++ b/include/linux/pcs/pcs-airoha.h
@@ -0,0 +1,16 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+#ifndef __LINUX_PCS_AIROHA_H
+#define __LINUX_PCS_AIROHA_H
+
+/* XFI_MAC */
+#define XFI_MAC_GIB_CFG		0x0
+#define XFI_MAC_LOGIC_RST	0x10
+#define XFI_MACADDRH		0x60
+#define XFI_MACADDRL		0x64
+#define XFI_CNT_CLR		0x100
+
+struct phylink_pcs *airoha_pcs_create(struct device *dev);
+void airoha_pcs_destroy(struct phylink_pcs *pcs);
+
+#endif /* __LINUX_PCS_AIROHA_H */
