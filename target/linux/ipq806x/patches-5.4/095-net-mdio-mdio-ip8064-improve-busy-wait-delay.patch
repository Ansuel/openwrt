From 429900ed89d7c53fff78ae9650333538d0bf730d Mon Sep 17 00:00:00 2001
From: Ansuel Smith <ansuelsmth@gmail.com>
Date: Fri, 5 Feb 2021 15:08:59 +0100
Subject: [PATCH 2/8] net: mdio: mdio-ip8064: improve busy wait delay

With the use of the qca8k dsa driver, some problem arised related to
port status detection. With a load on a specific port (for example a
simple speed test), the driver starts to bheave in a strange way and
random port starts to drop and reset. Some inspection of the various
mdio driver from qca present in uboot, it was discovered that a specific
version had different delay for the read and the write operation and
from the comments sets the wrong CLKRANGE.
Apply the different delay for the busy-wait function and fix the wrong
CLKRANGE flag

Signed-off-by: Ansuel Smith <ansuelsmth@gmail.com>
---
 drivers/net/phy/mdio-ipq8064.c | 80 ++++++++++++++++++++-------------
 1 file changed, 50 insertions(+), 30 deletions(-)

diff --git a/drivers/net/phy/mdio-ipq8064.c b/drivers/net/phy/mdio-ipq8064.c
index 1bd18857e1c5..df921671a108 100644
--- a/drivers/net/phy/mdio-ipq8064.c
+++ b/drivers/net/phy/mdio-ipq8064.c
@@ -15,45 +15,50 @@
 #include <linux/mfd/syscon.h>
 
 /* MII address register definitions */
-#define MII_ADDR_REG_ADDR                       0x10
-#define MII_BUSY                                BIT(0)
-#define MII_WRITE                               BIT(1)
-#define MII_CLKRANGE_60_100M                    (0 << 2)
-#define MII_CLKRANGE_100_150M                   (1 << 2)
-#define MII_CLKRANGE_20_35M                     (2 << 2)
-#define MII_CLKRANGE_35_60M                     (3 << 2)
-#define MII_CLKRANGE_150_250M                   (4 << 2)
-#define MII_CLKRANGE_250_300M                   (5 << 2)
-#define MII_CLKRANGE_MASK			GENMASK(4, 2)
-#define MII_REG_SHIFT				6
-#define MII_REG_MASK				GENMASK(10, 6)
-#define MII_ADDR_SHIFT				11
-#define MII_ADDR_MASK				GENMASK(15, 11)
-
-#define MII_DATA_REG_ADDR                       0x14
-
-#define MII_MDIO_DELAY_USEC                     (1000)
-#define MII_MDIO_RETRY_MSEC                     (10)
+#define MII_ADDR_REG_ADDR		0x10
+#define MII_DATA_REG_ADDR		0x14
+
+#define MII_REG_SHIFT			6
+#define MII_REG_MASK			GENMASK(10, 6)
+#define MII_ADDR_SHIFT			11
+#define MII_ADDR_MASK			GENMASK(15, 11)
+
+#define MII_BUSY			BIT(0)
+#define MII_WRITE			BIT(1)
+
+#define MII_CLKRANGE_60_100M		(0 << 2)
+#define MII_CLKRANGE_100_150M		(1 << 2)
+#define MII_CLKRANGE_20_35M		(2 << 2)
+#define MII_CLKRANGE_35_60M		(3 << 2)
+#define MII_CLKRANGE_150_250M		(4 << 2)
+#define MII_CLKRANGE_250_300M		(5 << 2)
+#define MII_CLKRANGE_MASK		GENMASK(4, 2)
+
+#define MII_MDIO_DELAY			(10)
+#define MII_MDIO_DELAY_REG31		(16)
+#define MII_MDIO_DELAY_READ		(10 * 2)
+#define MII_MDIO_DELAY_WRITE		(300 * 2)
+#define MII_MDIO_RETRY_MSEC		(MII_MDIO_DELAY_READ * USEC_PER_MSEC)
 
 struct ipq8064_mdio {
 	struct regmap *base; /* NSS_GMAC0_BASE */
 };
 
 static int
-ipq8064_mdio_wait_busy(struct ipq8064_mdio *priv)
+ipq8064_mdio_wait_busy(struct ipq8064_mdio *priv, int delay)
 {
 	u32 busy;
 
 	return regmap_read_poll_timeout(priv->base, MII_ADDR_REG_ADDR, busy,
-					!(busy & MII_BUSY), MII_MDIO_DELAY_USEC,
-					MII_MDIO_RETRY_MSEC * USEC_PER_MSEC);
+					!(busy & MII_BUSY), delay,
+					MII_MDIO_RETRY_MSEC);
 }
 
 static int
 ipq8064_mdio_read(struct mii_bus *bus, int phy_addr, int reg_offset)
 {
-	u32 miiaddr = MII_BUSY | MII_CLKRANGE_250_300M;
 	struct ipq8064_mdio *priv = bus->priv;
+	u32 miiaddr = MII_BUSY | MII_CLKRANGE_20_35M;
 	u32 ret_val;
 	int err;
 
@@ -65,20 +70,23 @@ ipq8064_mdio_read(struct mii_bus *bus, int phy_addr, int reg_offset)
 		   ((reg_offset << MII_REG_SHIFT) & MII_REG_MASK);
 
 	regmap_write(priv->base, MII_ADDR_REG_ADDR, miiaddr);
-	usleep_range(8, 10);
+	udelay(10);
 
-	err = ipq8064_mdio_wait_busy(priv);
+	/* With mdio read the busy wait is set to a min of 10us.
+	 * Use 20us to address usleep_range a min of 10us
+	 */
+	err = ipq8064_mdio_wait_busy(priv, MII_MDIO_DELAY_READ);
 	if (err)
 		return err;
 
 	regmap_read(priv->base, MII_DATA_REG_ADDR, &ret_val);
-	return (int)ret_val;
+	return (int)(ret_val & 0xFFFF);
 }
 
 static int
 ipq8064_mdio_write(struct mii_bus *bus, int phy_addr, int reg_offset, u16 data)
 {
-	u32 miiaddr = MII_WRITE | MII_BUSY | MII_CLKRANGE_250_300M;
+	u32 miiaddr = MII_WRITE | MII_BUSY | MII_CLKRANGE_20_35M;
 	struct ipq8064_mdio *priv = bus->priv;
 
 	/* Reject clause 45 */
@@ -90,10 +98,22 @@ ipq8064_mdio_write(struct mii_bus *bus, int phy_addr, int reg_offset, u16 data)
 	miiaddr |= ((phy_addr << MII_ADDR_SHIFT) & MII_ADDR_MASK) |
 		   ((reg_offset << MII_REG_SHIFT) & MII_REG_MASK);
 
+	/*
+	 * For the specific reg 31 extra time is needed or the next
+	 * read will produce grabage data.
+	 * The delay is 8 + 16
+	 */
 	regmap_write(priv->base, MII_ADDR_REG_ADDR, miiaddr);
-	usleep_range(8, 10);
-
-	return ipq8064_mdio_wait_busy(priv);
+	if (reg_offset == 31)
+		usleep_range(MII_MDIO_DELAY + MII_MDIO_DELAY_REG31,
+			     (MII_MDIO_DELAY * 2) + MII_MDIO_DELAY_REG31);
+	else
+		udelay(MII_MDIO_DELAY);
+
+	/* With mdio write the busy wait is set to a min of 300us.
+	 * Use 600us to address usleep_range a min of 300us
+	 */
+	return ipq8064_mdio_wait_busy(priv, MII_MDIO_DELAY_WRITE);
 }
 
 static int
-- 
2.30.0

