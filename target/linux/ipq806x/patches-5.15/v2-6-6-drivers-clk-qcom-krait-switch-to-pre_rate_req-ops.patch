From eb3d2b6f5493489d814cada0ac34f6c4d2e28b19 Mon Sep 17 00:00:00 2001
From: Ansuel Smith <ansuelsmth@gmail.com>
Date: Sat, 5 Feb 2022 02:29:45 +0100
Subject: [PATCH] drivers: clk: qcom: krait: switch to pre_rate_req ops

Drop the krait notifier and use pre_rate_req() ops to switch to a safe
parent while setting the hfpll.

Signed-off-by: Ansuel Smith <ansuelsmth@gmail.com>
---
 drivers/clk/qcom/clk-krait.c | 17 ++++++++--
 drivers/clk/qcom/clk-krait.h |  3 +-
 drivers/clk/qcom/krait-cc.c  | 66 ++++--------------------------------
 3 files changed, 23 insertions(+), 63 deletions(-)

diff --git a/drivers/clk/qcom/clk-krait.c b/drivers/clk/qcom/clk-krait.c
index 59f1af415b58..19a750a3950a 100644
--- a/drivers/clk/qcom/clk-krait.c
+++ b/drivers/clk/qcom/clk-krait.c
@@ -7,6 +7,7 @@
 #include <linux/io.h>
 #include <linux/delay.h>
 #include <linux/err.h>
+#include <linux/clk.h>
 #include <linux/clk-provider.h>
 #include <linux/spinlock.h>
 
@@ -39,6 +40,19 @@ static void __krait_mux_set_sel(struct krait_mux_clk *mux, int sel)
 	udelay(1);
 }
 
+static int krait_mux_pre_rate_req(struct clk_hw *hw,
+				  const struct clk_rate_request *next,
+				  struct clk_rate_request *pre)
+{
+	struct krait_mux_clk *mux = to_krait_mux_clk(hw);
+
+	pre->best_parent_hw = __clk_get_hw(mux->safe_clk);
+	pre->best_parent_rate = clk_get_rate(mux->safe_clk);
+	pre->rate = pre->best_parent_rate;
+
+	return 1;
+}
+
 static int krait_mux_set_parent(struct clk_hw *hw, u8 index)
 {
 	struct krait_mux_clk *mux = to_krait_mux_clk(hw);
@@ -50,8 +64,6 @@ static int krait_mux_set_parent(struct clk_hw *hw, u8 index)
 	if (__clk_is_enabled(hw->clk))
 		__krait_mux_set_sel(mux, sel);
 
-	mux->reparent = true;
-
 	return 0;
 }
 
@@ -57,8 +68,15 @@
 static void krait_mux_disable(struct clk_hw *hw)
 {
 	struct krait_mux_clk *mux = to_krait_mux_clk(hw);
-
-	__krait_mux_set_sel(mux, mux->safe_sel);
+	struct clk_hw *safe_hw;
+	int p_index;
+	u32 sel;
+
+	safe_hw = __clk_get_hw(mux->safe_clk);
+	p_index = clk_hw_get_parent_index(hw, safe_hw);
+	sel = clk_mux_index_to_val(mux->parent_map, 0, p_index);
+
+	__krait_mux_set_sel(mux, sel);
 }
 
 const struct clk_ops krait_mux_clk_ops = {
@@ -69,6 +81,7 @@ static u8 krait_mux_get_parent(struct clk_hw *hw)
 const struct clk_ops krait_mux_clk_ops = {
 	.enable = krait_mux_enable,
 	.disable = krait_mux_disable,
+	.pre_rate_req = krait_mux_pre_rate_req,
 	.set_parent = krait_mux_set_parent,
 	.get_parent = krait_mux_get_parent,
 	.determine_rate = __clk_mux_determine_rate_closest,
diff --git a/drivers/clk/qcom/clk-krait.h b/drivers/clk/qcom/clk-krait.h
index 9120bd2f5297..2eae5df6d5fd 100644
--- a/drivers/clk/qcom/clk-krait.h
+++ b/drivers/clk/qcom/clk-krait.h
@@ -12,10 +12,9 @@ struct krait_mux_clk {
 	u32		shift;
 	u32		en_mask;
 	bool		lpl;
-	u8		safe_sel;
 	u8		old_index;
-	bool		reparent;
 
+	struct clk	*safe_clk;
 	struct clk_hw	hw;
 	struct notifier_block   clk_nb;
 };
diff --git a/drivers/clk/qcom/krait-cc.c b/drivers/clk/qcom/krait-cc.c
index 4d4b657d33c3..0d71bcbb4b62 100644
--- a/drivers/clk/qcom/krait-cc.c
+++ b/drivers/clk/qcom/krait-cc.c
@@ -26,49 +26,6 @@ static unsigned int pri_mux_map[] = {
 	0,
 };
 
-/*
- * Notifier function for switching the muxes to safe parent
- * while the hfpll is getting reprogrammed.
- */
-static int krait_notifier_cb(struct notifier_block *nb,
-			     unsigned long event,
-			     void *data)
-{
-	int ret = 0;
-	struct krait_mux_clk *mux = container_of(nb, struct krait_mux_clk,
-						 clk_nb);
-	/* Switch to safe parent */
-	if (event == PRE_RATE_CHANGE) {
-		mux->old_index = krait_mux_clk_ops.get_parent(&mux->hw);
-		ret = krait_mux_clk_ops.set_parent(&mux->hw, mux->safe_sel);
-		mux->reparent = false;
-	/*
-	 * By the time POST_RATE_CHANGE notifier is called,
-	 * clk framework itself would have changed the parent for the new rate.
-	 * Only otherwise, put back to the old parent.
-	 */
-	} else if (event == POST_RATE_CHANGE) {
-		if (!mux->reparent)
-			ret = krait_mux_clk_ops.set_parent(&mux->hw,
-							   mux->old_index);
-	}
-
-	return notifier_from_errno(ret);
-}
-
-static int krait_notifier_register(struct device *dev, struct clk *clk,
-				   struct krait_mux_clk *mux)
-{
-	int ret = 0;
-
-	mux->clk_nb.notifier_call = krait_notifier_cb;
-	ret = clk_notifier_register(clk, &mux->clk_nb);
-	if (ret)
-		dev_err(dev, "failed to register clock notifier: %d\n", ret);
-
-	return ret;
-}
-
 static int
 krait_add_div(struct device *dev, int id, const char *s, unsigned int offset)
 {
@@ -137,7 +94,7 @@ krait_add_sec_mux(struct device *dev, int id, const char *s,
 	mux->shift = 2;
 	mux->parent_map = sec_mux_map;
 	mux->hw.init = &init;
-	mux->safe_sel = 0;
+	mux->safe_clk = __clk_lookup("qsb");
 
 	init.name = kasprintf(GFP_KERNEL, "krait%s_sec_mux", s);
 	if (!init.name)
@@ -153,11 +110,6 @@ krait_add_sec_mux(struct device *dev, int id, const char *s,
 
 	clk = devm_clk_register(dev, &mux->hw);
 
-	ret = krait_notifier_register(dev, clk, mux);
-	if (ret)
-		goto unique_aux;
-
-unique_aux:
 	if (unique_aux)
 		kfree(sec_mux_list[0]);
 err_aux:
@@ -190,7 +142,6 @@ krait_add_pri_mux(struct device *dev, int id, const char *s,
 	mux->lpl = id >= 0;
 	mux->parent_map = pri_mux_map;
 	mux->hw.init = &init;
-	mux->safe_sel = 2;
 
 	init.name = kasprintf(GFP_KERNEL, "krait%s_pri_mux", s);
 	if (!init.name)
@@ -214,12 +165,9 @@ krait_add_pri_mux(struct device *dev, int id, const char *s,
 		goto err_p2;
 	}
 
+	mux->safe_clk = __clk_lookup(p_names[2]);
 	clk = devm_clk_register(dev, &mux->hw);
 
-	ret = krait_notifier_register(dev, clk, mux);
-	if (ret)
-		goto err_p3;
-err_p3:
 	kfree(p_names[2]);
 err_p2:
 	kfree(p_names[1]);
@@ -302,7 +250,7 @@ static int krait_cc_probe(struct platform_device *pdev)
 		return -ENODEV;
 
 	/* Rate is 1 because 0 causes problems for __clk_mux_determine_rate */
-	clk = clk_register_fixed_rate(dev, "qsb", NULL, 0, 1);
+	clk = clk_register_fixed_rate(dev, "qsb", NULL, 0, 384000000);
 	if (IS_ERR(clk))
 		return PTR_ERR(clk);
 
@@ -356,24 +304,24 @@ static int krait_cc_probe(struct platform_device *pdev)
 	 */
 	cur_rate = clk_get_rate(l2_pri_mux_clk);
 	aux_rate = 384000000;
-	if (cur_rate == 1) {
+	if (cur_rate == 384000000) {
 		pr_info("L2 @ QSB rate. Forcing new rate.\n");
 		cur_rate = aux_rate;
 	}
 	clk_set_rate(l2_pri_mux_clk, aux_rate);
-	clk_set_rate(l2_pri_mux_clk, 2);
+	clk_set_rate(l2_pri_mux_clk, 600000000);
 	clk_set_rate(l2_pri_mux_clk, cur_rate);
 	pr_info("L2 @ %lu KHz\n", clk_get_rate(l2_pri_mux_clk) / 1000);
 	for_each_possible_cpu(cpu) {
 		clk = clks[cpu];
 		cur_rate = clk_get_rate(clk);
-		if (cur_rate == 1) {
+		if (cur_rate == 384000000) {
 			pr_info("CPU%d @ QSB rate. Forcing new rate.\n", cpu);
 			cur_rate = aux_rate;
 		}
 
 		clk_set_rate(clk, aux_rate);
-		clk_set_rate(clk, 2);
+		clk_set_rate(clk, 600000000);
 		clk_set_rate(clk, cur_rate);
 		pr_info("CPU%d @ %lu KHz\n", cpu, clk_get_rate(clk) / 1000);
 	}
-- 
2.34.1

